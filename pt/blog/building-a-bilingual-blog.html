<!DOCTYPE html>>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Criando um Blog Bilíngue com View Transitions - dan.rio</title>
    <link rel="stylesheet" href="/blog/static/css/styles.css">
    <link rel="stylesheet" href="/blog/static/css/post.css">
    <link rel="preload" href="/blog/static/js/theme.js" as="script">
    <script src="/blog/static/js/theme.js"></script>
    <script src="/blog/static/js/transitions.js" defer></script>
</head>
<body>
    <nav class="nav">
        <div class="nav-container">
            <a href="/blog/pt/index.html" class="logo">dan.rio</a>
            <div class="nav-right">
                <ul class="nav-links">
                    <li><a href="/blog/pt/index.html" class="active">BLOG</a></li>
                    <li><a href="/blog/pt/about.html">ABOUT</a></li>
                </ul>
                <a href="/blog/en/blog/building-a-bilingual-blog.html" class="lang-toggle" aria-label="Switch to English (currently Português)" data-current-lang="pt">
        <svg class="lang-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10"/>
            <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
        </svg>
        <span class="lang-text">
            <span class="lang-en ">EN</span>
            <span class="lang-sep">/</span>
            <span class="lang-pt active">PT</span>
        </span>
    </a>
                <button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme">
                    <svg class="sun-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/>
                        <line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/>
                        <line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                    <svg class="moon-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
            </div>
        </div>
    </nav>

    <main class="container">
        <article class="post" style="view-transition-name: post-container-2;">
            <header class="post-header">
                <a href="/blog/pt/index.html" class="back-link">← Back to Blog</a>
                
                <h1 class="post-title-large" style="view-transition-name: post-title-2;">CRIANDO UM BLOG BILÍNGUE COM VIEW TRANSITIONS</h1>
                <div class="post-meta">
                    <time class="post-date" style="view-transition-name: post-date-2;">October 25, 2025</time>
                    <span class="post-separator">•</span>
                    <span class="post-reading-time">11 min read</span>
                </div>
                <div class="post-tags"><span class="tag-pill">Web Development</span><span class="tag-pill">View Transitions API</span><span class="tag-pill">Gemini AI</span><span class="tag-pill">Static Sites</span></div>
            </header>

            <div class="post-body">
                <p class="lead" style="view-transition-name: post-excerpt-2;">
                    Como este blog funciona: geração estática em Python, tradução automática com Gemini, View Transitions API para navegação fluida e uma filosofia de construir com os padrões nativos da web.
                </p>
                <p>Este blog é uma plataforma construída com geração de site estático em Python, tradução automática via Gemini AI e transições de página fluidas usando a View Transitions API. Sem *frameworks*, sem dependências pesadas—apenas os padrões nativos da web fazendo um trabalho de verdade. A arquitetura é simples o suficiente para entender em uma tarde, poderosa o suficiente para parecer contínua em uso e pequena o suficiente para manter sozinho.</p>
<p>O objetivo do design não era construir o *blog engine* mais completo em recursos. Era construir o mais discreto. Um lugar onde a escrita aparece sem cerimônia, onde a navegação parece reorganizar o espaço em vez de carregar novas páginas e onde uma segunda língua emerge tão naturalmente quanto a primeira. Cada escolha técnica serve a esse objetivo.</p>
<h2>Geração Estática com Propósito</h2>
<p>No núcleo, há um script Python que lê arquivos markdown de <code>_source/posts</code> e escreve HTML para dois diretórios de saída: <code>/en</code> para inglês e <code>/pt</code> para português. O script usa <code>frontmatter</code> para analisar metadados YAML e <code>markdown</code> para converter o conteúdo do corpo. Não há sistema de *plugins*, nem *marketplace* de temas, nem abstrações sobre abstrações. O script compõe arquivos. Isso é tudo o que ele precisa fazer.</p>
<p>Cada arquivo markdown contém *front matter* com um título, data, excerto e *tags* opcionais. O script percorre o diretório de posts, carrega cada arquivo, extrai os metadados, converte o markdown para HTML e o injeta em um *template*. O *template* não é um sistema separado. É um *f-string* do Python que sabe onde a navegação vai, onde o título do post fica e como o rodapé deve fechar. O HTML de saída é gravado no disco com nomes de arquivos determinísticos derivados do *slug* do post.</p>
<pre><code class="language-python">def generate_post_html(post, post_number, lang='en'):
    lang_dir = LANGUAGES[lang]['dir']
    current_page = f&quot;blog/{post['slug']}.html&quot;

    return f&quot;&quot;&quot;&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;{lang}&quot;&gt;
&lt;head&gt;
    &lt;title&gt;{post['title']} - dan.rio&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{BASE_PATH}/static/css/styles.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;nav class=&quot;nav&quot;&gt;...&lt;/nav&gt;
    &lt;main class=&quot;container&quot;&gt;
        &lt;article class=&quot;post&quot;&gt;
            &lt;h1&gt;{post['title']}&lt;/h1&gt;
            &lt;div class=&quot;post-body&quot;&gt;{post['content']}&lt;/div&gt;
        &lt;/article&gt;
    &lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;&quot;&quot;&quot;
</code></pre>
<p>O *build* é determinístico. Execute-o duas vezes na mesma entrada e você obterá uma saída byte a byte idêntica. Isso torna o *cache* trivial e os *rebuilds* previsíveis. O único estado que persiste entre os *builds* é o *cache* de tradução, que discutiremos em um momento.</p>
<h2>Tradução como Conteúdo de Primeira Classe</h2>
<p>Cada post é escrito em inglês. Cada post é automaticamente traduzido para português brasileiro usando o modelo Gemini 2.0 Flash do Google. A tradução não é uma reflexão tardia. Faz parte do processo de *build*, armazenada em *cache* por *content hash*, e regenerada apenas quando a fonte em inglês é alterada.</p>
<p>O tradutor vive em <code>_source/translator.py</code>. Ele mantém um *cache* JSON em <code>_cache/translation-cache.json</code>, indexado por *slug* do post e *content hash*. Antes de solicitar uma tradução, o script verifica se o *content hash* atual corresponde ao *hash* em *cache*. Se corresponder, a tradução em *cache* é usada. Caso contrário, uma nova tradução é solicitada via Gemini API, e o *cache* é atualizado.</p>
<p>O *prompt* de tradução é cuidadoso. Ele diz ao modelo para localizar, não para traduzir literalmente. Termos técnicos que os brasileiros usam em inglês—<code>framework</code>, <code>backend</code>, <code>API</code>, <code>deploy</code>, <code>commit</code>—são preservados. Blocos de código são deixados intactos. A voz narrativa é adaptada para soar natural em português, mantendo o mesmo tom e ritmo do original.</p>
<pre><code class="language-python">def translate_post(self, slug: str, frontmatter: Dict, content: str):
    content_hash = self._calculate_content_hash(content)
    cached = self.cache.get_translation(slug, content_hash)
    if cached:
        return cached

    prompt = self._build_translation_prompt(frontmatter, content)
    response = self.model.generate_content(prompt)
    translated = self._parse_translation_response(response.text)

    self.cache.set_translation(slug, content_hash, translated)
    return translated
</code></pre>
<p>O resultado são dois sites completos e paralelos. Ambos são HTML estático. Ambos são autocontidos. Ambos podem ser servidos a partir de uma CDN sem infraestrutura de *backend*. O site em inglês vive em <code>/en</code>, o site em português em <code>/pt</code>, e o usuário pode alternar entre eles com um único clique. A alternância de idioma não recarrega a página. Ele navega com uma View Transition que preserva a posição de rolagem e o estado do filtro, fazendo com que a mudança pareça uma sobreposição em vez de um salto.</p>
<h2>Navegação Que Lembra</h2>
<p>O site usa a View Transitions API para animar entre as páginas. Esta API é exclusiva do Chromium, o que significa que o site tem como alvo Chrome, Edge, Brave e outros navegadores baseados no Chromium. Não há *polyfill*. Não há animação de *fallback*. Se a API não estiver disponível, a navegação funciona normalmente sem transições. Esta é uma troca deliberada: recursos de ponta para usuários em navegadores modernos, degradação elegante para todos os outros.</p>
<p>O script que lida com a navegação é pequeno. Ele vive em <code>static/js/transitions.js</code>. Quando você clica em um link interno, o script intercepta o clique, busca o novo HTML da página, analisa-o em um fragmento de documento e inicia uma View Transition. Dentro do *callback* de transição, o script troca o título do documento, as folhas de estilo, o conteúdo principal e a navegação, e então atualiza a URL com <code>history.pushState</code>. O navegador captura o estado "antes", executa o *callback* para atualizar o DOM, captura o estado "depois" e anima a diferença.</p>
<pre><code class="language-javascript">async function navigateTo(url) {
  const response = await fetch(url, { cache: 'no-cache' });
  const html = await response.text();
  const newDoc = new DOMParser().parseFromString(html, 'text/html');

  const transition = document.startViewTransition(() =&gt; {
    document.title = newDoc.title;
    const main = document.querySelector('main');
    const newMain = newDoc.querySelector('main');
    if (main &amp;&amp; newMain) main.replaceWith(newMain);
    history.pushState(null, '', url);
  });

  await transition.finished;
}
</code></pre>
<p>Todo o comportamento da animação é definido em CSS usando pseudo-elementos <code>::view-transition-*</code>. O JavaScript apenas aciona a API. O CSS define como o conteúdo antigo desaparece, como o novo conteúdo aparece e como os elementos compartilhados sofrem *morphing* entre os estados. Os cards de posts no índice se expandem em artigos completos. Os títulos permanecem no lugar e crescem. O fundo muda suavemente. A sensação não é de trocar de página, mas de reorganizar uma única superfície contínua.</p>
<p>A curva de *easing* é a mesma em todos os lugares: <code>cubic-bezier(0.4, 0, 0.2, 1)</code>. As durações são compartilhadas entre todas as interações: 300ms para efeitos rápidos de *hover*, 500ms para transições principais, 600ms para mudanças de tema. Essas constantes vivem em propriedades personalizadas CSS e se propagam através de cada animação no site. A consistência não é imposta por um *framework*. Ela é codificada no próprio sistema de design.</p>
<h2>Troca de Idioma como Tradução Espacial</h2>
<p>Uma das sutis continuidades do sistema é como a troca de idioma é sentida. Quando você alterna do inglês para o português, você não está saindo da página. Você está traduzindo a superfície que já está lendo. A posição de rolagem é preservada. O estado do filtro na página de índice é preservado. A URL muda de <code>/en/index.html</code> para <code>/pt/index.html</code>, mas seu lugar no documento não.</p>
<p>Este comportamento é detectado no script de navegação. Se a estrutura do caminho for idêntica, exceto pelo segmento <code>en</code> ou <code>pt</code>, a navegação é classificada como uma troca de idioma. A posição de rolagem é capturada antes do *fetch* e restaurada após a troca do DOM. Se você estava na metade de um artigo em inglês e muda para português, você permanece na metade do mesmo artigo em português. O conteúdo muda, mas o espaço não.</p>
<p>O mesmo princípio se aplica à filtragem na página de índice. Se você filtrou os posts por ano ou *tag* e mudar de idioma, o filtro permanece ativo. Os posts traduzidos aparecem com os mesmos critérios de seleção. Isso faz com que a experiência bilíngue pareça um único documento visualizado através de duas lentes, em vez de dois sites separados.</p>
<h2>Filtrando com FLIP</h2>
<p>A página de índice lista todos os posts com um painel de filtro para ano, mês e *tags*. A filtragem é instantânea. Quando você seleciona um ano, os posts que não correspondem desaparecem e os posts restantes se reorganizam em uma grade mais apertada. A reorganização é animada usando a técnica FLIP: First, Last, Invert, Play.</p>
<p>O script captura a posição inicial de cada card visível. Ele aplica o filtro, que esconde os cards que não correspondem e faz com que o layout flua novamente. Ele captura a posição final de cada card que permanece visível. Para cada card, ele calcula o delta entre a posição antiga e a nova posição, aplica uma transformação CSS para inverter o card de volta à sua posição inicial e, em seguida, anima a transformação de volta a zero.</p>
<pre><code class="language-javascript">const rects = new Map();
cards.forEach(card =&gt; {
  rects.set(card, card.getBoundingClientRect());
});

applyFilter();

cards.forEach(card =&gt; {
  const oldRect = rects.get(card);
  const newRect = card.getBoundingClientRect();
  const dx = oldRect.left - newRect.left;
  const dy = oldRect.top - newRect.top;

  card.style.transform = `translate(${dx}px, ${dy}px)`;
  requestAnimationFrame(() =&gt; {
    card.style.transition = 'transform 500ms var(--motion-easing)';
    card.style.transform = 'none';
  });
});
</code></pre>
<p>A grade nunca salta. Ela expira. Os cards se dissolvem e deslizam para novas posições na mesma janela de 500ms. O resultado parece deliberado, não surpreendente. O layout é sempre legível. O movimento explica o que mudou.</p>
<h2>Theme Transitions e Engenharia Anti-Flicker</h2>
<p>O site suporta temas claro e escuro. A alternância é um botão simples na barra de navegação. Quando você clica nele, o tema se propaga por toda a página ao longo de 600 milissegundos. As cores de fundo mudam, as cores do texto se ajustam, as bordas suavizam ou tornam-se mais nítidas e as sombras são recalculadas. A transição é suave porque é definida uma vez, em CSS, com uma única classe aplicada ao corpo.</p>
<p>Um desafio durante o desenvolvimento foi impedir o *flicker* visual quando as *theme transitions* se sobrepunham às View Transitions. Se ambos os sistemas estivessem animando os mesmos elementos simultaneamente, o resultado seria um breve *flash*. A solução foi remover as classes CSS conflitantes antes de iniciar uma View Transition e evitar seletores universais que aplicam transições a cada elemento de uma só vez.</p>
<p>A *theme transition* é controlada. Ela só se aplica quando a classe <code>theme-transitioning</code> está presente no corpo. Quando você alterna o tema, a classe é adicionada, o atributo do tema é atualizado e a classe é removida após a conclusão da transição. Isso garante que as mudanças de tema sejam animadas, mas a navegação não aciona *theme transitions* redundantes.</p>
<p>Outra fonte de *flicker* foi a remoção atrasada de animações CSS nos cards de posts. Na página de índice, os cards aparecem com uma animação escalonada quando a página é carregada pela primeira vez. Em navegações subsequentes, esta animação não deve ser executada. O script detecta a navegação verificando <code>document.referrer</code>. Se o *referrer* corresponder à origem do site, o script assume que o usuário navegou de outra página e desativa imediatamente a animação de introdução, adicionando <code>disable-animation</code> à grade de posts. Os cards aparecem instantaneamente, sem piscar ou reiniciar.</p>
<h2>Filosofia da Simplicidade</h2>
<p>A arquitetura não é minimalista por ser minimalista. É minimalista porque o problema é simples. Um blog é texto, algumas imagens e a sensação de que se mover através dele deve ser como virar uma página sem perder o seu lugar. As capacidades nativas do navegador são suficientes. O Python é suficiente. As dependências são escolhidas com cuidado. Se uma ferramenta não fizer o corte mais limpo, ela não entra no código base.</p>
<p>A View Transitions API é nativa do Chromium. Não requer *polyfill*, nem *wrapper*, nem etapa de *build*. O navegador já sabe como capturar dois estados do DOM e animar entre eles. Meu trabalho é decidir quando isso deve acontecer e impedir que o resto da página interfira. O CSS que descreve o movimento é declarativo. Ele é lido como uma partitura de coreografia, não como um programa.</p>
<p>As bibliotecas <code>frontmatter</code> e <code>markdown</code> do Python fazem exatamente uma coisa cada: analisar YAML e converter Markdown para HTML. Eles fazem isso bem. Eles não tentam ser sistemas de *build* ou roteadores. Eles analisam texto. Isso é tudo que eu preciso que eles façam. O script de *build* inteiro tem menos de 600 linhas de Python. Você pode lê-lo em uma sentada. Se você puder lê-lo, você pode alterá-lo.</p>
<h2>Manutenção Antecipada</h2>
<p>Recusar um *framework* aqui não é nostalgia. É um alinhamento com o problema. Cada linha de código neste sistema é um código que terei que ler novamente em seis meses ou seis anos. Cada dependência é uma potencial incompatibilidade futura. Cada abstração é um imposto sobre a compreensão. Então o sistema permanece pequeno. Permanece legível. Permanece mutável.</p>
<p>A ausência de maquinaria não é uma ideologia. É manutenção praticada com antecedência. Quando adiciono um novo post, escrevo markdown e executo o script de *build*. A tradução acontece automaticamente. O HTML é gerado. O *cache* é atualizado. O site está pronto para *deploy*. Não há servidor de *hot-reloading*. Não há configuração de *webpack*. Não há *package.json* com 300 dependências. Há um script Python, um arquivo markdown e uma pasta de HTML estático.</p>
<h2>O Contrato com o Leitor</h2>
<p>Para aqueles que querem adaptá-lo, o contrato é pequeno e explícito. Markdown entra, HTML sai. Um tradutor que respeita o código e a voz. Uma camada de navegação que nunca bloqueia *paints* com trabalho que poderia ter feito antes. Estilos que codificam o ritmo uma vez e o reutilizam em todos os lugares. Se você mudar uma coisa, deve sentir que mudou exatamente uma coisa, e o resto do sistema deve responder com calma proporcional.</p>
<p>A única esperteza é saber quando parar. O sistema poderia fazer mais. Poderia ter um CMS. Poderia ter visualização em tempo real. Poderia ter *analytics* e testes A/B e *widgets* de compartilhamento social. Ele não faz nenhuma dessas coisas porque nenhuma dessas coisas melhora a experiência de leitura. O objetivo não é construir uma plataforma. O objetivo é escrever e deixar que a escrita seja lida sem interferência.</p>
<p>Isto não é uma demonstração. É a versão mais simples de um documento vivo que eu poderia fazer sem mentir sobre o que a web já pode fazer. O *cache* lembra o que não mudou. O tradutor preserva o que não deve ser traduzido. A navegação mantém onde você estava olhando quando o idioma mudou. O sistema de movimento codifica quanto tempo as coisas devem levar e se recusa a discutir sobre isso. Cada decisão que o sistema toma está a serviço de uma única ideia: o documento é contínuo. Quando você se move através dele, o espaço se reorganiza, mas nunca quebra.</p>
<p>É isso que significa para um site estático parecer vivo.</p>
            </div>
        </article>
    </main>

    <footer class="footer">
        <div class="footer-container">
            <div class="social-links">
                <a href="https://x.com/dancavlli" target="_blank" rel="noopener" aria-label="Twitter">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                    </svg>
                </a>
                <a href="https://github.com/danielcavalli" target="_blank" rel="noopener" aria-label="GitHub">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                    </svg>
                </a>
                <a href="https://www.linkedin.com/in/cavallidaniel/" target="_blank" rel="noopener" aria-label="LinkedIn">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
                    </svg>
                </a>
            </div>
            <p class="copyright">© 2025 All Rights Reserved.</p>
        </div>
    </footer>
</body>
</html>