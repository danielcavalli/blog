<!DOCTYPE html>>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Criando um Blog Bilíngue com View Transitions - dan.rio</title>
    <link rel="stylesheet" href="/static/css/styles.css">
    <link rel="stylesheet" href="/static/css/post.css">
    <link rel="preload" href="/static/js/theme.js" as="script">
    <script src="/static/js/theme.js"></script>
    <script src="/static/js/transitions.js" defer></script>
</head>
<body>
    <nav class="nav" style="view-transition-name: site-nav;">
        <div class="nav-container">
            <a href="/pt/index.html" class="logo" style="view-transition-name: landing-title;">dan.rio</a>
            <div class="nav-right">
                <ul class="nav-links">
                    <li><a href="/pt/index.html" class="active" style="view-transition-name: nav-blog;">BLOG</a></li>
                    <li><a href="/pt/about.html" style="view-transition-name: nav-about;">ABOUT</a></li>
                    <li><a href="/pt/cv.html" style="view-transition-name: nav-cv;">CV</a></li>
                </ul>
                <div style="view-transition-name: lang-toggle;"><a href="/en/blog/building-a-bilingual-blog.html" class="lang-toggle" aria-label="Switch to English (currently Português)" data-current-lang="pt">
        <svg class="lang-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10"/>
            <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
        </svg>
        <span class="lang-text">
            <span class="lang-en ">EN</span>
            <span class="lang-sep">/</span>
            <span class="lang-pt active">PT</span>
        </span>
    </a></div>
                <button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme" style="view-transition-name: theme-toggle;">
                    <svg class="sun-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/>
                        <line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/>
                        <line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                    <svg class="moon-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
            </div>
        </div>
    </nav>

    <main class="container">
        <article class="post" style="view-transition-name: post-container-3;">
            <header class="post-header">
                <a href="/pt/index.html" class="back-link">← Back to Blog</a>
                
                <h1 class="post-title-large" style="view-transition-name: post-title-3;">CRIANDO UM BLOG BILÍNGUE COM VIEW TRANSITIONS</h1>
                <div class="post-meta">
                    <time class="post-date" style="view-transition-name: post-date-3;">October 25, 2025</time>
                    <span class="post-separator">•</span>
                    <span class="post-reading-time">11 min read</span>
                </div>
                <div class="post-tags"><span class="tag-pill">Desenvolvimento Web</span><span class="tag-pill">View Transitions API</span><span class="tag-pill">Gemini AI</span><span class="tag-pill">Sites Estáticos</span></div>
            </header>

            <div class="post-body">
                <p class="lead" style="view-transition-name: post-excerpt-3;">
                    Como este blog funciona: geração estática com Python, tradução automática com Gemini AI, View Transitions API para navegação fluida, e uma filosofia de construção com padrões web nativos.
                </p>
                <p>Este blog é uma plataforma construída com geração de site estático em Python, tradução automática via Gemini AI, e transições de página fluidas usando a View Transitions API. Sem frameworks, sem dependências pesadas — apenas padrões web nativos fazendo o trabalho real. A arquitetura é simples o suficiente para ser compreendida em uma tarde, poderosa o suficiente para proporcionar uma experiência contínua no uso, e pequena o suficiente para ser mantida por uma pessoa só.</p>
<p>O objetivo do design não era construir o mecanismo de blog mais completo em termos de funcionalidades. Era construir o mais discreto. Um lugar onde a escrita aparece sem cerimônia, onde a navegação parece reorganizar o espaço em vez de carregar novas páginas, e onde uma segunda língua surge tão naturalmente quanto a primeira. Cada escolha técnica serve a esse objetivo.</p>
<h2>Geração Estática com Propósito</h2>
<p>No cerne, há um script Python que lê arquivos markdown de <code>_source/posts</code> e escreve HTML em dois diretórios de saída: <code>/enpara inglês e/pt</code> para português. O script usa frontmatter para analisar metadata YAML e markdown para converter o conteúdo do corpo. Não há sistema de plugins, nem marketplace de temas, nem abstrações sobre abstrações. O script compõe arquivos. É tudo o que ele precisa fazer.</p>
<p>Cada arquivo markdown contém front matter com um título, data, trecho e tags opcionais. O script percorre o diretório de posts, carrega cada arquivo, extrai a metadata, converte o markdown para HTML e o injeta em um modelo. O modelo não é um sistema separado. É uma f-string Python que sabe onde a navegação se encaixa, onde o título do post fica e como o rodapé deve fechar. O HTML de saída é escrito no disco com nomes de arquivo determinísticos derivados do slug do post.</p>
<pre><code class="language-python">def generate_post_html(post, post_number, lang='en'):
    lang_dir = LANGUAGES[lang]['dir']
    current_page = f&quot;blog/{post['slug']}.html&quot;

    return f&quot;&quot;&quot;&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;{lang}&quot;&gt;
&lt;head&gt;
    &lt;title&gt;{post['title']} - dan.rio&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{BASE_PATH}/static/css/styles.css&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;nav class=&quot;nav&quot;&gt;...&lt;/nav&gt;
    &lt;main class=&quot;container&quot;&gt;
        &lt;article class=&quot;post&quot;&gt;
            &lt;h1&gt;{post['title']}&lt;/h1&gt;
            &lt;div class=&quot;post-body&quot;&gt;{post['content']}&lt;/div&gt;
        &lt;/article&gt;
    &lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;&quot;&quot;&quot;
</code></pre>
<p>O build é determinístico. Execute-o duas vezes com a mesma entrada e você obterá uma saída idêntica byte a byte. Isso torna o caching trivial e os rebuilds previsíveis. O único estado que persiste entre os builds é o translation cache, que discutiremos em breve.</p>
<h2>Tradução como Conteúdo de Primeira Classe</h2>
<p>Todo post é escrito em inglês. Todo post é automaticamente traduzido para o português do Brasil usando o modelo Gemini 2.0 Flash do Google. A tradução não é um processo secundário. Ela faz parte do processo de build, é cached por hash de conteúdo e regenerada apenas quando a fonte em inglês muda.</p>
<p>O tradutor reside em <code>_source/translator.py</code>. Ele mantém um JSON cache em <code>_cache/translation-cache.json</code>, indexado por slug do post e hash de conteúdo. Antes de solicitar uma tradução, o script verifica se o hash de conteúdo atual corresponde ao hash cached. Se sim, a tradução cached é utilizada. Se não, uma nova tradução é solicitada via Gemini API, e o cache é atualizado.</p>
<p>O prompt de tradução é cuidadoso. Ele instrui o modelo a localizar, não a traduzir literalmente. Termos técnicos que brasileiros usam em inglês — framework, backend, API, deploy, commit — são preservados. Blocos de código são deixados intocados. A voz narrativa é adaptada para soar natural em português, mantendo o mesmo tom e ritmo do original.</p>
<pre><code class="language-python">def translate_post(self, slug: str, frontmatter: Dict, content: str):
    content_hash = self._calculate_content_hash(content)
    cached = self.cache.get_translation(slug, content_hash)
    if cached:
        return cached

    prompt = self._build_translation_prompt(frontmatter, content)
    response = self.model.generate_content(prompt)
    translated = self._parse_translation_response(response.text)

    self.cache.set_translation(slug, content_hash, translated)
    return translated
</code></pre>
<p>O resultado são dois sites completos e paralelos. Ambos são HTML estático. Ambos são autocontidos. Ambos podem ser servidos de uma CDN sem infraestrutura de backend. O site em inglês reside em <code>/en</code>, o site em português em <code>/pt</code>, e o usuário pode alternar entre eles com um único clique. A alternância de idioma não recarrega a página. Ela navega com uma View Transition que preserva a posição de rolagem e o estado do filtro, fazendo com que a troca pareça uma sobreposição em vez de um salto.</p>
<h2>Navegação que Lembra</h2>
<p>O site usa a View Transitions API para animar entre páginas. Esta API é exclusiva do Chromium, o que significa que o site visa Chrome, Edge, Brave e outros navegadores baseados em Chromium. Não há polyfill. Não há animação de contingência. Se a API não estiver disponível, a navegação funciona normalmente sem transições. Isso é uma troca deliberada: funcionalidades de ponta para usuários em navegadores modernos, degradação graciosa para todos os outros.</p>
<p>O script que lida com a navegação é pequeno. Ele reside em <code>static/js/transitions.js</code>. Quando você clica em um link interno, o script intercepta o clique, busca o novo HTML da página, analisa-o em um fragmento de documento e inicia uma View Transition. Dentro do callback de transição, o script troca o título do documento, as folhas de estilo, o conteúdo principal e a navegação, então atualiza a URL com <code>history.pushState</code>. O navegador captura o estado "antes", executa o callback para atualizar o DOM, captura o estado "depois" e anima a diferença.</p>
<pre><code class="language-javascript">async function navigateTo(url) {
  const response = await fetch(url, { cache: 'no-cache' });
  const html = await response.text();
  const newDoc = new DOMParser().parseFromString(html, 'text/html');

  const transition = document.startViewTransition(() =&gt; {
    document.title = newDoc.title;
    const main = document.querySelector('main');
    const newMain = newDoc.querySelector('main');
    if (main &amp;&amp; newMain) main.replaceWith(newMain);
    history.pushState(null, '', url);
  });

  await transition.finished;
}
</code></pre>
<p>Todo o comportamento de animação é definido em CSS usando pseudo-elementos <code>::view-transition-*</code>. JavaScript apenas dispara a API. O CSS define como o conteúdo antigo desaparece, como o novo conteúdo aparece e como os elementos compartilhados se transformam entre os estados. Cards de posts no índice se expandem em artigos completos. Títulos permanecem no lugar e crescem. O fundo muda suavemente. A sensação não é de trocar de página, mas de reorganizar uma única superfície contínua.</p>
<p>A curva de easing é a mesma em todos os lugares: <code>cubic-bezier(0.4, 0, 0.2, 1)</code>. As durações são compartilhadas em todas as interações: 300ms para efeitos rápidos de hover, 500ms para transições principais, 600ms para mudanças de tema. Essas constantes residem em propriedades CSS customizadas e se propagam por toda animação no site. A consistência não é imposta por um framework. Ela é codificada no próprio design system.</p>
<h2>Troca de Idioma como Tradução Espacial</h2>
<p>Uma das sutis continuidades do sistema é como a troca de idioma é percebida. Quando você alterna do inglês para o português, não está saindo da página. Você está traduzindo a superfície que já está lendo. A posição de rolagem é preservada. O estado do filtro na página de índice é preservado. A URL muda de <code>/en/index.htmlpara/pt/index.html</code>, mas seu lugar no documento não.</p>
<p>Este comportamento é detectado no script de navegação. Se a estrutura do path for idêntica, exceto pelo segmento en ou pt, a navegação é classificada como uma troca de idioma. A posição de rolagem é capturada antes do fetch e restaurada após a troca do DOM. Se você estava na metade de um artigo em inglês e troca para português, você permanece na metade do mesmo artigo em português. O conteúdo muda, mas o espaço não.</p>
<p>O mesmo princípio se aplica à filtragem na página de índice. Se você filtrou posts por ano ou tag, e troca de idioma, o filtro permanece ativo. Os posts traduzidos aparecem com os mesmos critérios de seleção. Isso faz com que a experiência bilíngue pareça um único documento visto através de duas lentes, em vez de dois sites separados.</p>
<h2>Filtragem com FLIP</h2>
<p>A página de índice lista todos os posts com um painel de filtro por ano, mês e tags. A filtragem é instantânea. Quando você seleciona um ano, os posts que não correspondem desaparecem, e os posts restantes se reorganizam em uma grade mais compacta. A reorganização é animada usando a técnica FLIP: First, Last, Invert, Play.</p>
<p>O script captura a posição inicial de cada card visível. Ele aplica o filtro, que esconde os cards que não correspondem e faz com que o layout seja refluído. Ele captura a posição final de cada card que permanece visível. Para cada card, ele calcula o delta entre a posição antiga e a nova posição, aplica um CSS transform para inverter o card de volta à sua posição inicial, e então anima o transform de volta a zero.</p>
<pre><code class="language-javascript">const rects = new Map();
cards.forEach(card =&gt; {
  rects.set(card, card.getBoundingClientRect());
});

applyFilter();

cards.forEach(card =&gt; {
  const oldRect = rects.get(card);
  const newRect = card.getBoundingClientRect();
  const dx = oldRect.left - newRect.left;
  const dy = oldRect.top - newRect.top;

  card.style.transform = `translate(${dx}px, ${dy}px)`;
  requestAnimationFrame(() =&gt; {
    card.style.transition = 'transform 500ms var(--motion-easing)';
    card.style.transform = 'none';
  });
});
</code></pre>
<p>A grade nunca salta. Ela exala. Cards se dissolvem e deslizam para novas posições ao longo da mesma janela de 500ms. O resultado parece deliberado, não surpreendente. O layout é sempre legível. O movimento explica o que mudou.</p>
<h2>Transições de Tema e Engenharia Anti-Flicker</h2>
<p>O site suporta temas claros e escuros. O toggle é um botão simples na barra de navegação. Quando você clica nele, o tema se propaga por toda a página em 600 milissegundos. Cores de fundo mudam, cores de texto se ajustam, bordas suavizam ou acentuam, e sombras são recalculadas. A transição é suave porque é definida uma vez, em CSS, com uma única classe aplicada ao body.</p>
<p>Um desafio durante o desenvolvimento foi prevenir o flicker visual quando as transições de tema se sobrepunham às View Transitions. Se ambos os sistemas estivessem animando os mesmos elementos simultaneamente, o resultado era um breve lampejo. A solução foi remover classes CSS conflitantes antes de iniciar uma View Transition, e evitar seletores universais que aplicam transições a cada elemento de uma vez.</p>
<p>A transição de tema é condicionada. Ela só se aplica quando a classe theme-transitioning está presente no body. Quando você alterna o tema, a classe é adicionada, o atributo de tema é atualizado e a classe é removida após a conclusão da transição. Isso garante que as mudanças de tema sejam animadas, mas a navegação não dispara transições de tema redundantes.</p>
<p>Outra fonte de flicker foi a remoção atrasada de animações CSS em cards de posts. Na página de índice, os cards aparecem com uma animação escalonada quando a página carrega pela primeira vez. Em navegações subsequentes, essa animação não deve ser executada. O script detecta a navegação verificando <code>document.referrer</code>. Se o referrer corresponde à origem do site, o script assume que o usuário navegou de outra página e desativa imediatamente a animação de introdução adicionando disable-animation à grade de posts. Os cards aparecem instantaneamente sem piscar ou redefinir.</p>
<h2>Filosofia da Simplicidade</h2>
<p>A arquitetura não é mínima por ser mínima. Ela é mínima porque o problema é simples. Um blog é texto, algumas imagens e a sensação de que se mover por ele deve parecer virar uma página sem perder o seu lugar. As capacidades nativas do navegador são suficientes. Python é suficiente. As dependências são escolhidas cuidadosamente. Se uma ferramenta não torna o corte mais limpo, ela não entra na base de código.</p>
<p>A View Transitions API é nativa do Chromium. Não exige polyfill, nem wrapper, nem etapa de build. O navegador já sabe como capturar dois estados do DOM e animar entre eles. Meu trabalho é decidir quando isso deve acontecer e evitar que o restante da página interfira. O CSS que descreve o movimento é declarativo. Ele se lê como uma partitura de coreografia, não como um programa.</p>
<p>As bibliotecas frontmatter e markdown do Python fazem exatamente uma coisa cada: analisam YAML e convertem Markdown para HTML. Elas fazem isso bem. Não tentam ser sistemas de build ou roteadores. Elas analisam texto. É tudo o que preciso que façam. O script de build inteiro tem menos de 600 linhas de Python. Você pode lê-lo de uma vez. Se você pode lê-lo, você pode mudá-lo.</p>
<h2>Manutenção Antecipada</h2>
<p>Recusar um framework aqui não é nostalgia. É um alinhamento com o problema. Cada linha de código neste sistema é código que terei que ler novamente em seis meses ou seis anos. Cada dependência é uma potencial incompatibilidade futura. Toda abstração é um imposto sobre a compreensão. Então o sistema permanece pequeno. Permanece legível. Permanece mutável.</p>
<p>A ausência de maquinário não é uma ideologia. É manutenção praticada com antecedência. Quando adiciono um novo post, escrevo markdown e executo o script de build. A tradução acontece automaticamente. O HTML é gerado. O cache é atualizado. O site está pronto para deploy. Não há hot-reloading server. Não há configuração webpack. Não há package.json com 300 dependências. Há um script Python, um arquivo markdown e uma pasta de HTML estático.</p>
<h2>O Contrato com o Leitor</h2>
<p>Para aqueles que desejam adaptá-lo, o contrato é pequeno e explícito. Markdown dentro, HTML fora. Um tradutor que respeita código e voz. Uma camada de navegação que nunca bloqueia as renderizações com trabalho que poderia ter sido feito antes. Estilos que codificam o ritmo uma vez e o reutilizam em todos os lugares. Se você muda uma coisa, deve parecer que mudou exatamente uma coisa, e o restante do sistema deve responder com calma proporcional.</p>
<p>A única inteligência está em saber quando parar. O sistema poderia fazer mais. Poderia ter um CMS. Poderia ter preview em tempo real. Poderia ter analytics e A/B testing e widgets de compartilhamento social. Ele não faz nenhuma dessas coisas porque nenhuma delas melhora a experiência de leitura. O objetivo não é construir uma plataforma. O objetivo é escrever, e deixar que a escrita seja lida sem interferência.</p>
<p>Isso não é uma demonstração. É a versão mais simples de um documento vivo que eu poderia fazer sem mentir sobre o que a web já pode fazer. O cache lembra o que não mudou. O tradutor preserva o que não deve ser traduzido. A navegação mantém onde você estava olhando quando o idioma mudou. O sistema de movimento codifica quanto tempo as coisas devem levar e se recusa a discutir sobre isso. Toda decisão que o sistema toma está a serviço de uma única ideia: o documento é contínuo. Quando você se move por ele, o espaço se reorganiza, mas nunca se rompe.</p>
<p>É isso que significa para um site estático se sentir vivo.</p>
            </div>
        </article>
    </main>

    <footer class="footer" style="view-transition-name: site-footer;">
        <div class="footer-container">
            <div class="social-links">
                <a href="https://x.com/dancavlli" target="_blank" rel="noopener" aria-label="Twitter">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                    </svg>
                </a>
                <a href="https://github.com/danielcavalli" target="_blank" rel="noopener" aria-label="GitHub">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                    </svg>
                </a>
                <a href="https://www.linkedin.com/in/cavallidaniel/" target="_blank" rel="noopener" aria-label="LinkedIn">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
                    </svg>
                </a>
            </div>
            <p class="copyright">© 2025 All Rights Reserved.</p>
        </div>
    </footer>
</body>
</html>