<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>O Sistema Estático Vivo - dan.rio</title>
    <link rel="stylesheet" href="/static/css/styles.css">
    <link rel="stylesheet" href="/static/css/post.css">
    <link rel="preload" href="/static/js/theme.js" as="script">
    <script src="/static/js/theme.js"></script>
    <script src="/static/js/transitions.js" defer></script>
</head>
<body>
    <nav class="nav" style="view-transition-name: site-nav;">
        <div class="nav-container">
            <a href="/pt/index.html" class="logo" style="view-transition-name: landing-title;">dan.rio</a>
            <div class="nav-right">
                <ul class="nav-links">
                    <li><a href="/pt/index.html" class="active" style="view-transition-name: nav-blog;">BLOG</a></li>
                    <li><a href="/pt/about.html" style="view-transition-name: nav-about;">ABOUT</a></li>
                    <li><a href="/pt/cv.html" style="view-transition-name: nav-cv;">CV</a></li>
                </ul>
                <div style="view-transition-name: lang-toggle;"><a href="/en/blog/the-living-static-system.html" class="lang-toggle" aria-label="Switch to English (currently Português)" data-current-lang="pt">
        <svg class="lang-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10"/>
            <path d="M2 12h20M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
        </svg>
        <span class="lang-text">
            <span class="lang-en">EN</span>
            <span class="lang-sep">/</span>
            <span class="lang-pt active">PT</span>
        </span>
    </a></div>
                <button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme" style="view-transition-name: theme-toggle;">
                    <svg class="sun-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="5"/>
                        <line x1="12" y1="1" x2="12" y2="3"/>
                        <line x1="12" y1="21" x2="12" y2="23"/>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                        <line x1="1" y1="12" x2="3" y2="12"/>
                        <line x1="21" y1="12" x2="23" y2="12"/>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
                    </svg>
                    <svg class="moon-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                    </svg>
                </button>
            </div>
        </div>
    </nav>

    <main class="container">
        <article class="post" style="view-transition-name: post-container-2;">
            <header class="post-header">
                <a href="/pt/index.html" class="back-link">← Back to Blog</a>
                <div class="last-updated">Last updated: November 25, 2025 at 11:03 PM</div>
                <h1 class="post-title-large" style="view-transition-name: post-title-2;">O SISTEMA ESTÁTICO VIVO</h1>
                <div class="post-meta">
                    <time class="post-date" style="view-transition-name: post-date-2;">October 25, 2025</time>
                    <span class="post-separator">•</span>
                    <span class="post-reading-time">11 min read</span>
                </div>
                <div class="post-tags"><span class="tag-pill">Desenvolvimento Web</span><span class="tag-pill">View Transitions API</span><span class="tag-pill">Sites Estáticos</span><span class="tag-pill">Python</span></div>
            </header>

            <div class="post-body">
                <p class="lead" style="view-transition-name: post-excerpt-2;">
                    Por dentro de um site estático bilíngue que se move como uma única superfície: um build em Python, um pipeline de tradução e transições nativas que mantêm o espaço contínuo.
                </p>
                <p>O sistema começou como uma pergunta: o quão pouco um blog precisa para se sentir vivo. Não animado por si só, mas vivo da forma como uma maré avança: inevitável, contínua, sem fronteiras. O que surgiu é um gerador estático que escreve dois espelhos de si mesmo, um em inglês e outro em português, e uma fina camada de movimento que nunca rompe a superfície. Páginas não trocam. O espaço se reorganiza.</p>
<h2>O Pipeline de Build</h2>
<p>O build é uma única passagem de trabalho deliberado. Markdown entra por uma porta estreita. O front matter é lido, o conteúdo é analisado e um modelo de página é montado com estrutura suficiente para renderizar precisamente o que é necessário e nada mais. O script não orquestra um framework. Ele compõe arquivos.</p>
<p>Dentro de <code>_source/build.py</code>, posts são descobertos ao percorrer o diretório <code>_source/posts</code>. Cada arquivo markdown é analisado com a biblioteca frontmatter, que separa a metadata YAML do conteúdo principal. O corpo flui através da biblioteca markdown do Python com extensões para blocos de código cercados e tabelas. O que sai do outro lado é HTML limpo envolto em um template que sabe exatamente onde o título vai, onde a data fica e como a navegação deve fluir.</p>
<p>O único cache que importa é aquele que respeita a mudança. Um hash de conteúdo é computado a partir da fonte em inglês usando MD5, e qualquer transformação que se segue herda essa decisão. O hash vive no próprio front matter, escrito de volta ao arquivo markdown após a análise:</p>
<pre><code class="language-python">def parse_markdown_post(filepath):
    post = frontmatter.load(filepath)
    content_hash = calculate_content_hash(post.content)

    stored_hash = post.get('content_hash')
    needs_update = False

    if not created_at:
        # New post - set creation date
        post['created_at'] = now
        post['content_hash'] = content_hash
        needs_update = True
    elif stored_hash != content_hash:
        # Content changed - update timestamp
        post['updated_at'] = now
        post['content_hash'] = content_hash
        needs_update = True
</code></pre>
<p>Quando nada muda, nada é reconstruído. Quando uma frase se move, o pipeline acorda e se move com ela. O script de build escreve em dois diretórios de saída, <code>/ene /pt</code>, ambos na raiz do projeto. Ambos são sites completos. Ambos são de primeira classe. Não há fallback e nenhuma busca em runtime.</p>
<h2>Tradução como um Espelho</h2>
<p>Tradução não é uma decoração. É uma segunda superfície desenhada com a mesma mão. Inglês entra; português sai via Gemini com restrições que preservam blocos de código, terminologia técnica e o tom do original.</p>
<p>O tradutor é inicializado com uma API key do ambiente. Ele mantém um arquivo de cache JSON em <code>_cache/translation-cache.json</code>, com chave pelo slug de cada post e o hash do conteúdo. A regra é simples: se a fonte não mudou, a tradução já é verdadeira. Se o hash for diferente, uma nova tradução é solicitada e o cache é atualizado atomicamente.</p>
<p>O prompt de tradução não é uma instrução simples. É um contrato:</p>
<blockquote>
<p>Você é um redator técnico brasileiro bilíngue traduzindo um post de blog em inglês para um português brasileiro natural e localizado. Sua tarefa não é realizar uma tradução literal, mas localizar o texto—transformando-o em algo que soe como se tivesse sido originalmente escrito em português pelo mesmo autor.</p>
</blockquote>
<p>O prompt continua com princípios: preservar termos técnicos que os brasileiros usam em inglês (framework, build, pipeline, deploy), mas localizar conteúdo narrativo e pessoal para soar fluente e culturalmente preciso. O tradutor respeita a essência do original, fazendo com que cada frase respire naturalmente na segunda língua.</p>
<pre><code class="language-python">translated = translator.translate_post(
    slug, frontmatter, content
)
</code></pre>
<p>O resultado é armazenado em cache, e o próximo build ignora a chamada da API por completo. É assim que um site bilíngue pode ser reconstruído em segundos, em vez de minutos. O cache é a memória do que já foi dito.</p>
<h2>Navegação como Espaço Contínuo</h2>
<p>A navegação se comporta como se o documento fosse um único plano que aprende novas formas. No navegador, a View Transitions API não é um efeito especial. É uma memória do antes e do depois. Novo HTML é buscado antecipadamente. A troca acontece dentro de um único callback síncrono e o navegador captura dois estados do mesmo espaço. O código é pequeno porque o navegador está fazendo o que foi projetado para fazer.</p>
<p>A função navigateTo em <code>static/js/transitions.js</code> intercepta cliques em links internos. Ela busca a nova página, a analisa em um fragmento de documento e prepara a troca. Antes do início da transição, ela remove atributos view-transition-name dos cartões de posts no novo documento. Isso impede que o navegador crie pseudo-elementos extras que piscarão durante a limpeza. Então a transição começa:</p>
<pre><code class="language-javascript">const transition = document.startViewTransition(() =&gt; {
  document.title = newDoc.title;

  const main = document.querySelector('main');
  const newMain = newDoc.querySelector('main');
  if (main &amp;&amp; newMain) main.replaceWith(newMain);

  history.pushState(null, '', url);
  window.scrollTo({ top: 0, behavior: 'instant' });
});

await transition.finished;
</code></pre>
<p>A coreografia é escrita em CSS, não em JavaScript. O código acima apenas decide quando a superfície deve se lembrar. Todo o resto vive nos estilos: curvas de easing compartilhadas entre interações, durações que rimam e pseudo-elementos <code>::view-transition</code> que permitem que os títulos se transformem sem nunca desaparecer. As constantes de movimento ficam em um só lugar e não negociam com o resto do design:</p>
<pre><code class="language-css">:root {
  --motion-duration-core: 500ms;
  --motion-duration-quick: 300ms;
  --motion-duration-ripple: 600ms;
  --motion-easing: cubic-bezier(0.4, 0, 0.2, 1);
}
</code></pre>
<p>Cada interação no site usa essas variáveis. Os cartões de posts levantam no hover por 300ms. As transições de tema se espalham por 600ms. As View transitions se transformam por 500ms. A consistência não é um acidente. É o som do mesmo relógio ticando em todos os lugares.</p>
<h2>Filtragem Sem Surpresas</h2>
<p>Os cartões na página de índice aprendem a se comportar como bons cidadãos. Seu primeiro dever é aparecer e depois ficar parados. A ordenação e filtragem são feitas com FLIP, não com surpresa. FLIP significa First, Last, Invert, Play (Primeiro, Último, Inverter, Tocar): mede onde cada cartão começa, aplica o filtro ou ordenação, mede onde cada cartão termina e então anima o delta.</p>
<p>A implementação em <code>static/js/filter.js</code> captura os retângulos delimitadores iniciais de todos os cartões visíveis, aplica a lógica do filtro para ocultar ou mostrar cartões e então captura as posições finais. Cada cartão que se moveu recebe uma transformação CSS para invertê-lo de volta à sua posição inicial, e então a transformação é removida ao longo da duração da animação. O cartão parece deslizar suavemente da posição antiga para a nova.</p>
<pre><code class="language-javascript">const rects = new Map();
cards.forEach(card =&gt; {
  rects.set(card, card.getBoundingClientRect());
});

// Apply filter (hides/shows cards, layout reflows)
applyFilter();

cards.forEach(card =&gt; {
  const oldRect = rects.get(card);
  const newRect = card.getBoundingClientRect();
  const dx = oldRect.left - newRect.left;
  const dy = oldRect.top - newRect.top;

  card.style.transform = `translate(${dx}px, ${dy}px)`;
  requestAnimationFrame(() =&gt; {
    card.style.transition = 'transform 500ms var(--motion-easing)';
    card.style.transform = 'none';
  });
});
</code></pre>
<p>A grade nunca pula. Ela expira. Quando a navegação chega de outro lugar, a revelação do keyframe inicial é totalmente ignorada. O script detecta a navegação verificando <code>document.referrer</code> para a mesma origem. Se o referrer corresponder, ele assume que o usuário navegou de outra página no site, e imediatamente desativa a animação de introdução adicionando disable-animation à grade de posts e configurando <code>animation: none</code> em cada cartão. O resultado é silencioso: nada pisca, nada reinicia, nada se afirma após o fato.</p>
<h2>Troca de Idioma como Sobreposição de Tradução</h2>
<p>Uma das continuidades mais sutis do sistema é como a troca de idioma se sente. Quando você clica no alternador de idioma, você não está saindo da página. Você está traduzindo a superfície que já está lendo. A posição de rolagem é preservada. O estado do filtro é preservado. A URL muda de <code>/en/index.htmlpara/pt/index.html</code>, mas seu lugar no documento não.</p>
<p>Isso é tratado em <code>transitions.js</code> detectando uma troca de idioma: a estrutura do caminho é idêntica, exceto pelo segmento en ou pt. Se este padrão for detectado, a posição de rolagem é capturada antes da busca e restaurada após a troca do DOM. Se você estava na metade de um longo artigo em inglês e troca para português, você permanece na metade do mesmo artigo. O conteúdo muda, mas o espaço não.</p>
<p>O mesmo princípio se estende ao estado do filtro na página de índice. Se você filtrou posts por ano ou tag e muda de idioma, o filtro permanece ativo. Os posts traduzidos aparecem, mas os critérios de seleção são preservados. É assim que um site bilíngue se parece com um único documento visto através de duas lentes, em vez de dois sites separados.</p>
<h2>Customização Sem Scaffolding</h2>
<p>A customização respeita a essência do sistema. O ponto de entrada é a configuração e o texto, não o scaffolding. Abra <code>_source/config.py</code> e você encontrará tudo o que pode mudar: caminho base, definições de idioma, metadata do site e strings de UI para ambos os idiomas. Mude o caminho base e o build escreve links que obedecem. Ajuste as variáveis tipográficas em <code>static/css/styles.css</code> e toda a superfície se ajusta ou se solta uniformemente.</p>
<p>O conjunto de idiomas é a única suposição embutida. O inglês é a fonte da verdade. O português é uma tradução fiel. Se um terceiro idioma for necessário, a regra se estende: adicione um segundo espelho, dê a ele um cache, mantenha os hashes honestos. O construtor é um script que você pode ler de uma vez só. Se você pode lê-lo, você pode mudá-lo. Não há mágica. Não há camadas ocultas. O sistema é exatamente tão complexo quanto o problema que ele resolve.</p>
<h2>Por Que Nenhum Framework</h2>
<p>Recusar um framework aqui não é nostalgia. É um alinhamento com o problema. Um blog é texto, algumas imagens e a sensação de que mover-se por ele deve parecer virar uma página sem perder a linha que você estava lendo. As capacidades nativas do navegador já são suficientes. Python já é suficiente. As dependências são escolhidas como ferramentas em uma pequena bancada: se uma ferramenta não torna o corte mais limpo, ela permanece na gaveta.</p>
<p>A ausência de maquinário não é uma ideologia. É manutenção praticada com antecedência. Cada linha de código neste sistema é código que terei que ler novamente em seis meses ou seis anos. Cada dependência é uma potencial incompatibilidade futura. Cada abstração é um imposto sobre a compreensão. Então o sistema permanece pequeno. Permanece legível. Permanece mutável.</p>
<p>A View Transitions API é nativa do Chromium. Não requer polyfill, wrapper, nem etapa de build. O navegador já sabe como capturar dois estados do DOM e animar entre eles. Meu trabalho é decidir quando isso deve acontecer e evitar que o resto da página interfira. O CSS que descreve o movimento é declarativo. Ele se lê como uma partitura de coreografia, não como um programa.</p>
<p>As bibliotecas frontmatter e markdown do Python fazem exatamente uma coisa cada: analisar YAML e converter Markdown para HTML. Elas fazem isso bem. Elas não tentam ser sistemas de build. Elas não tentam ser roteadores. Elas analisam texto. É tudo o que preciso que elas façam.</p>
<h2>A Filosofia do Movimento</h2>
<p>A filosofia do movimento é a filosofia da atenção. Nada deve insistir. As transições respondem a três perguntas: de onde, para onde e como este estado se relaciona com o anterior. As mudanças de tema se espalham como uma nuvem passando sobre o sol. Um cartão levanta alguns pixels ao passar o mouse, e então retorna ao repouso. A superfície nunca mente sobre o que se moveu ou por quê.</p>
<p>Quando algo deve ser removido, ele se dissolve ao longo de 500 milissegundos. Quando algo deve chegar, ele emerge de onde poderia plausivelmente ter estado. O cartão do post no índice se expande para o artigo completo. O título permanece no lugar e cresce. A data se ancora no canto. O layout se expande para fora sem quebrar a continuidade. Quando você pressiona voltar, o artigo se contrai no cartão novamente. O espaço é conservado.</p>
<p>A curva de easing é a mesma em todos os lugares: <code>cubic-bezier(0.4, 0, 0.2, 1)</code>. Esta não é uma escolha aleatória. É o easing padrão do Material Design, escolhido porque parece natural à percepção humana. O movimento começa com intenção, acelera suavemente e desacelera ao ser concluído. Nada estala. Nada desliza em velocidade constante. Tudo se move como se tivesse peso.</p>
<h2>O Contrato com o Leitor</h2>
<p>Para aqueles que desejam adaptá-lo, o contrato é pequeno e explícito. Markdown entra, HTML sai. Um tradutor que respeita o código e a voz. Uma camada de navegação que nunca bloqueia as renderizações com trabalho que poderia ter feito antes. Estilos que codificam o ritmo uma vez e o reutilizam em todos os lugares. Se você mudar uma coisa, deve parecer que você mudou exatamente uma coisa e o resto do sistema deve responder com calma proporcional.</p>
<p>A única inteligência está em saber quando parar. O sistema poderia fazer mais. Poderia ter um CMS. Poderia ter pré-visualização em tempo real. Poderia ter analytics, testes A/B e widgets de compartilhamento social. Ele não faz nenhuma dessas coisas porque nenhuma delas torna a experiência de leitura melhor. O objetivo não é construir uma plataforma. O objetivo é escrever e permitir que a escrita seja lida sem interferência.</p>
<h2>O Que o Sistema Sabe</h2>
<p>Esta não é uma demonstração. É a versão mais simples de um documento vivo que eu poderia fazer sem mentir sobre o que a web já pode fazer. Na maioria das noites, escrevo com as janelas abertas em Copacabana e o som da avenida se dobrando no mar. O sistema aprende esse ritmo e o mantém. As coisas fluem não porque são rápidas, mas porque não se metem no próprio caminho.</p>
<p>O cache se lembra do que não mudou. O tradutor preserva o que não deve ser traduzido. A navegação mantém onde você estava olhando quando o idioma foi trocado. O sistema de movimento codifica quanto tempo as coisas devem levar e se recusa a discutir sobre isso. Cada decisão que o sistema toma está a serviço de uma única ideia: o documento é contínuo. Quando você se move por ele, o espaço se reorganiza, mas nunca se quebra.</p>
<p>É isso que significa para um site estático se sentir vivo.</p>
            </div>
        </article>
    </main>

    <footer class="footer" style="view-transition-name: site-footer;">
        <div class="footer-container">
            <div class="social-links">
                <a href="https://x.com/dancavlli" target="_blank" rel="noopener" aria-label="Twitter">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
                    </svg>
                </a>
                <a href="https://github.com/danielcavalli" target="_blank" rel="noopener" aria-label="GitHub">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                    </svg>
                </a>
                <a href="https://www.linkedin.com/in/cavallidaniel/" target="_blank" rel="noopener" aria-label="LinkedIn">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
                    </svg>
                </a>
            </div>
            <p class="copyright">© 2025 All Rights Reserved.</p>
        </div>
    </footer>
</body>
</html>